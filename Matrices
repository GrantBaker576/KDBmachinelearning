.gmb.mat.chiSquareDistanceRow:{[table]
    //takes table of categorical variables, returns chisquare distance matrix of rows(observations)
    n:count table;
    p:count cols table;
    cDT:flip value flip .gmb.preprocessing.oneHotEncoder[table][`CDT];
    step1:{[x;y]y[x]<>/:y}\:[til n;cDT]; //diff of CDT entries squared
    step2:{[step1;cDT]step1[til count cDT]%\:(sum cDT)}\:[step1;cDT]; //step2 divide each entry by sum of columns of CDT
    :({[x;y]sum each y[x]}\:[til count cDT;step2])*n%p; //matrix of chi squared distance between rows
    };

.gmb.mat.chiSquareDistanceColumn:{[table]
    //takes table of categorical variables, returns chisquare distance matrix of cols(variables)
    n:count table;
    cDT:flip value flip .gmb.preprocessing.oneHotEncoder[table][`CDT];
    //n* sums squar diffs between CDT columns
    :n*sum each {[n;cDT] flip((flip cDT)[n] <>/: (flip cDT)[til count flip cDT])}\:[til count flip cDT;cDT]; 
 };

.gmb.mat.covarianceMatrix:{(x+flip(not n=\:n)*x:(n#'0.0),'(x$/:'(n:til count x)_\:x)%count first x)-a*\:a:avg each x} //from .stat.q

.gmb.mat.getDiagonal:{[x]
    //retrieves diagonal from a matrix
    :x@'til count x;
    }; 

.gmb.mat.mahalanobisDistance:{[dataSet]
    //takes a table OR array
    //each observation is included in set of observations
    //room for improvement on finding covariance table
    $[98h=type dataSet;matrix:"f"$(value flip dataSet);matrix:"f"$dataSet]; //takes a table or array, turns into an array
    observation:(flip matrix);
    step1: observation -\: (avg each matrix);
    covMatrix:(matrix) scov/:\:(matrix);
    step2:(step1) mmu (inv covMatrix);
    step3:sqrt (step2 mmu/: step1);
    Mahalanobis:.gmb.mat.getDiagonal[step3];
    :flip (enlist `Mahalanobis)!(enlist Mahalanobis);
    };
